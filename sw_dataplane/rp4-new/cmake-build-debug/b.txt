header ethernet_t {
	bit<48>	dst_addr;
	bit<48>	src_addr;
	bit<16>	ether_type;
}
header vlan_tag_t {
	bit<3>	pcp;
	bit<1>	cfi;
	bit<12>	vid;
	bit<16>	ether_type;
}
header ipv4_t {
	bit<4>	version;
	bit<4>	ihl;
	bit<8>	diffserv;
	bit<16>	total_len;
	bit<16>	identification;
	bit<3>	flags;
	bit<13>	frag_offset;
	bit<8>	ttl;
	bit<8>	protocol;
	bit<16>	hdr_checksum;
	bit<32>	src_addr;
	bit<32>	dst_addr;
}
header ipv6_t {
	bit<4>	version;
	bit<8>	traffic_class;
	bit<20>	flow_label;
	bit<16>	payload_len;
	bit<8>	next_hdr;
	bit<8>	hop_limit;
	bit<128>	src_addr;
	bit<128>	dst_addr;
}
header tcp_t {
	bit<16>	src_port;
	bit<16>	dst_port;
	bit<32>	seq_no;
	bit<32>	ack_no;
	bit<4>	data_offset;
	bit<4>	res;
	bit<8>	flags;
	bit<16>	window;
	bit<16>	checksum;
	bit<16>	urgent_ptr;
}
header udp_t {
	bit<16>	src_port;
	bit<16>	dst_port;
	bit<16>	hdr_length;
	bit<16>	checksum;
}
struct lookup_fields_t {
	bit<48>	mac_src_addr;
	bit<48>	mac_dst_addr;
	bit<16>	mac_type;
	bit<4>	ip_version;
	bit<8>	ip_proto;
	bit<8>	ip_ttl;
	bit<8>	ip_dscp;
	bit<20>	ipv6_flow_label;
	bit<32>	ipv4_src_addr;
	bit<32>	ipv4_dst_addr;
	bit<128>	ipv6_src_addr;
	bit<128>	ipv6_dst_addr;
} lkp_0;
struct metadata {
	bit<1>	fib_tmp;
	bit<1>	fibv6_tmp;
	bit<1>	nexthop_routed;
	bit<16>	metadata_t_bd;
	bit<16>	metadata_t_vrf;
	bit<16>	metadata_t_nexthop;
	bit<16>	metadata_t_ifindex;
	bit<16>	metadata_t_egress_ifindex;
	bit<8>	metadata_t_bypass;
} meta;
struct headers {
	ethernet_t	ethernet;
	vlan_tag_t	vlan_tag;
	ipv4_t	ipv4;
	ipv6_t	ipv6;
	tcp_t	tcp;
	udp_t	udp;
} hdr;

struct standard_metadata_t {
    bit<9> ingress_port;
    bit<9> egress_spec;
    bit<9> egress_port;
    bit<32> clone_spec;
    bit<32> instance_type;
    bit<1> drop;
    bit<16> recirculate_port;
    bit<32> packet_length;
} standard_metadata;

parser MyParser(packet_in packet) {
	state start {
		packet.extract(hdr.ethernet);
		transition select(hdr.ethernet.ether_type) {
			0x0800: parse_ipv4;
			0x86dd: parse_ipv6;
			0x8100: parse_vlan;
			default: accept;
		}
	}
	state parse_vlan {
		packet.extract(hdr.vlan_tag);
		transition select(hdr.vlan_tag.ether_type) {
			0x0800: parse_ipv4;
			0x86dd: parse_ipv6;
			default: accept;
		}
	}
	state parse_ipv4 {
		packet.extract(hdr.ipv4);
		transition select(hdr.ipv4.protocol) {
			0x06: parse_tcp;
			0x11: parse_udp;
			default: accept;
		}
	}
	state parse_ipv6 {
		packet.extract(hdr.ipv6);
		transition select(hdr.ipv6.next_hdr) {
			0x06: parse_tcp;
			0x11: parse_udp;
			default: accept;
		}
	}
	state parse_tcp {
		packet.extract(hdr.tcp);
		transition accept;
	}
	state parse_udp {
		packet.extract(hdr.udp);
		transition accept;
	}
}

del stage smac_rewrite_s
add stage
stage smac_rewrite_s {
    parser {
    };
    matcher {
        switch (1) {
            0b1: table(smac_rewrite);
        }
    };
    executor {
        rewrite_smac: dmac_s;
        NoAction_7: dmac_s;
    };
}
add parser vlan_tag in stage port_mapping_s