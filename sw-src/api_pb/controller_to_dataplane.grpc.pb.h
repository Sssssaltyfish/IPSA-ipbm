// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: controller_to_dataplane.proto
#ifndef GRPC_controller_5fto_5fdataplane_2eproto__INCLUDED
#define GRPC_controller_5fto_5fdataplane_2eproto__INCLUDED

#include "controller_to_dataplane.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace rp4 {

class CfgService final {
 public:
  static constexpr char const* service_full_name() {
    return "rp4.CfgService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // ***** metadata ****
    virtual ::grpc::Status setMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::rp4::SetMetadataResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMetadataResp>> AsyncsetMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMetadataResp>>(AsyncsetMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMetadataResp>> PrepareAsyncsetMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMetadataResp>>(PrepareAsyncsetMetadataRaw(context, request, cq));
    }
    // **** parser ****
    virtual ::grpc::Status initParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::rp4::ParserLevelResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ParserLevelResp>> AsyncinitParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ParserLevelResp>>(AsyncinitParserLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ParserLevelResp>> PrepareAsyncinitParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ParserLevelResp>>(PrepareAsyncinitParserLevelRaw(context, request, cq));
    }
    virtual ::grpc::Status modParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::rp4::ModParserEntryResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModParserEntryResp>> AsyncmodParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModParserEntryResp>>(AsyncmodParserEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModParserEntryResp>> PrepareAsyncmodParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModParserEntryResp>>(PrepareAsyncmodParserEntryRaw(context, request, cq));
    }
    virtual ::grpc::Status clearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::rp4::ClearParserResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearParserResp>> AsyncclearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearParserResp>>(AsyncclearParserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearParserResp>> PrepareAsyncclearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearParserResp>>(PrepareAsyncclearParserRaw(context, request, cq));
    }
    // **** gateway ****
    virtual ::grpc::Status insertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::rp4::InsertRelationExpResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertRelationExpResp>> AsyncinsertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertRelationExpResp>>(AsyncinsertRelationExpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertRelationExpResp>> PrepareAsyncinsertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertRelationExpResp>>(PrepareAsyncinsertRelationExpRaw(context, request, cq));
    }
    virtual ::grpc::Status clearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::rp4::ClearRelationExpResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearRelationExpResp>> AsyncclearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearRelationExpResp>>(AsyncclearRelationExpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearRelationExpResp>> PrepareAsyncclearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearRelationExpResp>>(PrepareAsyncclearRelationExpRaw(context, request, cq));
    }
    virtual ::grpc::Status clearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::rp4::ClearResMapResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearResMapResp>> AsyncclearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearResMapResp>>(AsyncclearResMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearResMapResp>> PrepareAsyncclearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearResMapResp>>(PrepareAsyncclearResMapRaw(context, request, cq));
    }
    virtual ::grpc::Status modResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::rp4::ModResMapResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModResMapResp>> AsyncmodResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModResMapResp>>(AsyncmodResMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModResMapResp>> PrepareAsyncmodResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModResMapResp>>(PrepareAsyncmodResMapRaw(context, request, cq));
    }
    virtual ::grpc::Status setDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::rp4::SetDefaultGateEntryResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetDefaultGateEntryResp>> AsyncsetDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetDefaultGateEntryResp>>(AsyncsetDefaultGateEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetDefaultGateEntryResp>> PrepareAsyncsetDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetDefaultGateEntryResp>>(PrepareAsyncsetDefaultGateEntryRaw(context, request, cq));
    }
    // ***** matcher ******
    virtual ::grpc::Status setNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::rp4::SetNoTableResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetNoTableResp>> AsyncsetNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetNoTableResp>>(AsyncsetNoTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetNoTableResp>> PrepareAsyncsetNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetNoTableResp>>(PrepareAsyncsetNoTableRaw(context, request, cq));
    }
    virtual ::grpc::Status setActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::rp4::SetActionProcResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetActionProcResp>> AsyncsetActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetActionProcResp>>(AsyncsetActionProcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetActionProcResp>> PrepareAsyncsetActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetActionProcResp>>(PrepareAsyncsetActionProcRaw(context, request, cq));
    }
    virtual ::grpc::Status setMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::rp4::SetMemConfigResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMemConfigResp>> AsyncsetMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMemConfigResp>>(AsyncsetMemConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMemConfigResp>> PrepareAsyncsetMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMemConfigResp>>(PrepareAsyncsetMemConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status setFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::rp4::SetFieldInfoResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetFieldInfoResp>> AsyncsetFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetFieldInfoResp>>(AsyncsetFieldInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetFieldInfoResp>> PrepareAsyncsetFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetFieldInfoResp>>(PrepareAsyncsetFieldInfoRaw(context, request, cq));
    }
    //  rpc setHitMissBitmap (SetHitMissBitmapReq) returns (SetHitMissBitmapResp);
    virtual ::grpc::Status clearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::rp4::ClearOldConfigResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearOldConfigResp>> AsyncclearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearOldConfigResp>>(AsyncclearOldConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearOldConfigResp>> PrepareAsyncclearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearOldConfigResp>>(PrepareAsyncclearOldConfigRaw(context, request, cq));
    }
    //  rpc setHitActId (SetHitActIdReq) returns (SetHitActIdResp);
    virtual ::grpc::Status setMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::rp4::SetMissActIdResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMissActIdResp>> AsyncsetMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMissActIdResp>>(AsyncsetMissActIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMissActIdResp>> PrepareAsyncsetMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMissActIdResp>>(PrepareAsyncsetMissActIdRaw(context, request, cq));
    }
    // table entry
    virtual ::grpc::Status insertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::rp4::InsertSramEntryResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertSramEntryResp>> AsyncinsertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertSramEntryResp>>(AsyncinsertSramEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertSramEntryResp>> PrepareAsyncinsertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertSramEntryResp>>(PrepareAsyncinsertSramEntryRaw(context, request, cq));
    }
    virtual ::grpc::Status insertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::rp4::InsertTcamEntryResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertTcamEntryResp>> AsyncinsertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertTcamEntryResp>>(AsyncinsertTcamEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertTcamEntryResp>> PrepareAsyncinsertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertTcamEntryResp>>(PrepareAsyncinsertTcamEntryRaw(context, request, cq));
    }
    // ***** executor ******
    virtual ::grpc::Status insertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::rp4::InsertActionResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertActionResp>> AsyncinsertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertActionResp>>(AsyncinsertActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertActionResp>> PrepareAsyncinsertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertActionResp>>(PrepareAsyncinsertActionRaw(context, request, cq));
    }
    virtual ::grpc::Status clearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::rp4::ClearActionResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearActionResp>> AsyncclearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearActionResp>>(AsyncclearActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearActionResp>> PrepareAsyncclearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearActionResp>>(PrepareAsyncclearActionRaw(context, request, cq));
    }
    virtual ::grpc::Status delAction(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::rp4::DelActionResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::DelActionResp>> AsyncdelAction(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::DelActionResp>>(AsyncdelActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::DelActionResp>> PrepareAsyncdelAction(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rp4::DelActionResp>>(PrepareAsyncdelActionRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // ***** metadata ****
      virtual void setMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq* request, ::rp4::SetMetadataResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq* request, ::rp4::SetMetadataResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // **** parser ****
      virtual void initParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq* request, ::rp4::ParserLevelResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void initParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq* request, ::rp4::ParserLevelResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void modParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq* request, ::rp4::ModParserEntryResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq* request, ::rp4::ModParserEntryResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void clearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq* request, ::rp4::ClearParserResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq* request, ::rp4::ClearParserResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // **** gateway ****
      virtual void insertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq* request, ::rp4::InsertRelationExpResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq* request, ::rp4::InsertRelationExpResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void clearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq* request, ::rp4::ClearRelationExpResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq* request, ::rp4::ClearRelationExpResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void clearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq* request, ::rp4::ClearResMapResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq* request, ::rp4::ClearResMapResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void modResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq* request, ::rp4::ModResMapResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq* request, ::rp4::ModResMapResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void setDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq* request, ::rp4::SetDefaultGateEntryResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq* request, ::rp4::SetDefaultGateEntryResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ***** matcher ******
      virtual void setNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq* request, ::rp4::SetNoTableResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq* request, ::rp4::SetNoTableResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void setActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq* request, ::rp4::SetActionProcResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq* request, ::rp4::SetActionProcResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void setMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq* request, ::rp4::SetMemConfigResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq* request, ::rp4::SetMemConfigResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void setFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq* request, ::rp4::SetFieldInfoResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq* request, ::rp4::SetFieldInfoResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //  rpc setHitMissBitmap (SetHitMissBitmapReq) returns (SetHitMissBitmapResp);
      virtual void clearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq* request, ::rp4::ClearOldConfigResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq* request, ::rp4::ClearOldConfigResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //  rpc setHitActId (SetHitActIdReq) returns (SetHitActIdResp);
      virtual void setMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq* request, ::rp4::SetMissActIdResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq* request, ::rp4::SetMissActIdResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // table entry
      virtual void insertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq* request, ::rp4::InsertSramEntryResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq* request, ::rp4::InsertSramEntryResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void insertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq* request, ::rp4::InsertTcamEntryResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq* request, ::rp4::InsertTcamEntryResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ***** executor ******
      virtual void insertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq* request, ::rp4::InsertActionResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void insertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq* request, ::rp4::InsertActionResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void clearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq* request, ::rp4::ClearActionResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq* request, ::rp4::ClearActionResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void delAction(::grpc::ClientContext* context, const ::rp4::DelActionReq* request, ::rp4::DelActionResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void delAction(::grpc::ClientContext* context, const ::rp4::DelActionReq* request, ::rp4::DelActionResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMetadataResp>* AsyncsetMetadataRaw(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMetadataResp>* PrepareAsyncsetMetadataRaw(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ParserLevelResp>* AsyncinitParserLevelRaw(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ParserLevelResp>* PrepareAsyncinitParserLevelRaw(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModParserEntryResp>* AsyncmodParserEntryRaw(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModParserEntryResp>* PrepareAsyncmodParserEntryRaw(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearParserResp>* AsyncclearParserRaw(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearParserResp>* PrepareAsyncclearParserRaw(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertRelationExpResp>* AsyncinsertRelationExpRaw(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertRelationExpResp>* PrepareAsyncinsertRelationExpRaw(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearRelationExpResp>* AsyncclearRelationExpRaw(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearRelationExpResp>* PrepareAsyncclearRelationExpRaw(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearResMapResp>* AsyncclearResMapRaw(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearResMapResp>* PrepareAsyncclearResMapRaw(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModResMapResp>* AsyncmodResMapRaw(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ModResMapResp>* PrepareAsyncmodResMapRaw(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetDefaultGateEntryResp>* AsyncsetDefaultGateEntryRaw(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetDefaultGateEntryResp>* PrepareAsyncsetDefaultGateEntryRaw(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetNoTableResp>* AsyncsetNoTableRaw(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetNoTableResp>* PrepareAsyncsetNoTableRaw(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetActionProcResp>* AsyncsetActionProcRaw(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetActionProcResp>* PrepareAsyncsetActionProcRaw(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMemConfigResp>* AsyncsetMemConfigRaw(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMemConfigResp>* PrepareAsyncsetMemConfigRaw(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetFieldInfoResp>* AsyncsetFieldInfoRaw(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetFieldInfoResp>* PrepareAsyncsetFieldInfoRaw(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearOldConfigResp>* AsyncclearOldConfigRaw(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearOldConfigResp>* PrepareAsyncclearOldConfigRaw(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMissActIdResp>* AsyncsetMissActIdRaw(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::SetMissActIdResp>* PrepareAsyncsetMissActIdRaw(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertSramEntryResp>* AsyncinsertSramEntryRaw(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertSramEntryResp>* PrepareAsyncinsertSramEntryRaw(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertTcamEntryResp>* AsyncinsertTcamEntryRaw(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertTcamEntryResp>* PrepareAsyncinsertTcamEntryRaw(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertActionResp>* AsyncinsertActionRaw(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::InsertActionResp>* PrepareAsyncinsertActionRaw(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearActionResp>* AsyncclearActionRaw(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::ClearActionResp>* PrepareAsyncclearActionRaw(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::DelActionResp>* AsyncdelActionRaw(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rp4::DelActionResp>* PrepareAsyncdelActionRaw(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status setMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::rp4::SetMetadataResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMetadataResp>> AsyncsetMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMetadataResp>>(AsyncsetMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMetadataResp>> PrepareAsyncsetMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMetadataResp>>(PrepareAsyncsetMetadataRaw(context, request, cq));
    }
    ::grpc::Status initParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::rp4::ParserLevelResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ParserLevelResp>> AsyncinitParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ParserLevelResp>>(AsyncinitParserLevelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ParserLevelResp>> PrepareAsyncinitParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ParserLevelResp>>(PrepareAsyncinitParserLevelRaw(context, request, cq));
    }
    ::grpc::Status modParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::rp4::ModParserEntryResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ModParserEntryResp>> AsyncmodParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ModParserEntryResp>>(AsyncmodParserEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ModParserEntryResp>> PrepareAsyncmodParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ModParserEntryResp>>(PrepareAsyncmodParserEntryRaw(context, request, cq));
    }
    ::grpc::Status clearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::rp4::ClearParserResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearParserResp>> AsyncclearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearParserResp>>(AsyncclearParserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearParserResp>> PrepareAsyncclearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearParserResp>>(PrepareAsyncclearParserRaw(context, request, cq));
    }
    ::grpc::Status insertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::rp4::InsertRelationExpResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertRelationExpResp>> AsyncinsertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertRelationExpResp>>(AsyncinsertRelationExpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertRelationExpResp>> PrepareAsyncinsertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertRelationExpResp>>(PrepareAsyncinsertRelationExpRaw(context, request, cq));
    }
    ::grpc::Status clearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::rp4::ClearRelationExpResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearRelationExpResp>> AsyncclearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearRelationExpResp>>(AsyncclearRelationExpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearRelationExpResp>> PrepareAsyncclearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearRelationExpResp>>(PrepareAsyncclearRelationExpRaw(context, request, cq));
    }
    ::grpc::Status clearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::rp4::ClearResMapResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearResMapResp>> AsyncclearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearResMapResp>>(AsyncclearResMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearResMapResp>> PrepareAsyncclearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearResMapResp>>(PrepareAsyncclearResMapRaw(context, request, cq));
    }
    ::grpc::Status modResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::rp4::ModResMapResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ModResMapResp>> AsyncmodResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ModResMapResp>>(AsyncmodResMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ModResMapResp>> PrepareAsyncmodResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ModResMapResp>>(PrepareAsyncmodResMapRaw(context, request, cq));
    }
    ::grpc::Status setDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::rp4::SetDefaultGateEntryResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetDefaultGateEntryResp>> AsyncsetDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetDefaultGateEntryResp>>(AsyncsetDefaultGateEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetDefaultGateEntryResp>> PrepareAsyncsetDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetDefaultGateEntryResp>>(PrepareAsyncsetDefaultGateEntryRaw(context, request, cq));
    }
    ::grpc::Status setNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::rp4::SetNoTableResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetNoTableResp>> AsyncsetNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetNoTableResp>>(AsyncsetNoTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetNoTableResp>> PrepareAsyncsetNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetNoTableResp>>(PrepareAsyncsetNoTableRaw(context, request, cq));
    }
    ::grpc::Status setActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::rp4::SetActionProcResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetActionProcResp>> AsyncsetActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetActionProcResp>>(AsyncsetActionProcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetActionProcResp>> PrepareAsyncsetActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetActionProcResp>>(PrepareAsyncsetActionProcRaw(context, request, cq));
    }
    ::grpc::Status setMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::rp4::SetMemConfigResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMemConfigResp>> AsyncsetMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMemConfigResp>>(AsyncsetMemConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMemConfigResp>> PrepareAsyncsetMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMemConfigResp>>(PrepareAsyncsetMemConfigRaw(context, request, cq));
    }
    ::grpc::Status setFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::rp4::SetFieldInfoResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetFieldInfoResp>> AsyncsetFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetFieldInfoResp>>(AsyncsetFieldInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetFieldInfoResp>> PrepareAsyncsetFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetFieldInfoResp>>(PrepareAsyncsetFieldInfoRaw(context, request, cq));
    }
    ::grpc::Status clearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::rp4::ClearOldConfigResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearOldConfigResp>> AsyncclearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearOldConfigResp>>(AsyncclearOldConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearOldConfigResp>> PrepareAsyncclearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearOldConfigResp>>(PrepareAsyncclearOldConfigRaw(context, request, cq));
    }
    ::grpc::Status setMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::rp4::SetMissActIdResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMissActIdResp>> AsyncsetMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMissActIdResp>>(AsyncsetMissActIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMissActIdResp>> PrepareAsyncsetMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::SetMissActIdResp>>(PrepareAsyncsetMissActIdRaw(context, request, cq));
    }
    ::grpc::Status insertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::rp4::InsertSramEntryResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertSramEntryResp>> AsyncinsertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertSramEntryResp>>(AsyncinsertSramEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertSramEntryResp>> PrepareAsyncinsertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertSramEntryResp>>(PrepareAsyncinsertSramEntryRaw(context, request, cq));
    }
    ::grpc::Status insertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::rp4::InsertTcamEntryResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertTcamEntryResp>> AsyncinsertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertTcamEntryResp>>(AsyncinsertTcamEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertTcamEntryResp>> PrepareAsyncinsertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertTcamEntryResp>>(PrepareAsyncinsertTcamEntryRaw(context, request, cq));
    }
    ::grpc::Status insertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::rp4::InsertActionResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertActionResp>> AsyncinsertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertActionResp>>(AsyncinsertActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertActionResp>> PrepareAsyncinsertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::InsertActionResp>>(PrepareAsyncinsertActionRaw(context, request, cq));
    }
    ::grpc::Status clearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::rp4::ClearActionResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearActionResp>> AsyncclearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearActionResp>>(AsyncclearActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearActionResp>> PrepareAsyncclearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::ClearActionResp>>(PrepareAsyncclearActionRaw(context, request, cq));
    }
    ::grpc::Status delAction(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::rp4::DelActionResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::DelActionResp>> AsyncdelAction(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::DelActionResp>>(AsyncdelActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::DelActionResp>> PrepareAsyncdelAction(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rp4::DelActionResp>>(PrepareAsyncdelActionRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void setMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq* request, ::rp4::SetMetadataResp* response, std::function<void(::grpc::Status)>) override;
      void setMetadata(::grpc::ClientContext* context, const ::rp4::SetMetadataReq* request, ::rp4::SetMetadataResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void initParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq* request, ::rp4::ParserLevelResp* response, std::function<void(::grpc::Status)>) override;
      void initParserLevel(::grpc::ClientContext* context, const ::rp4::ParserLevelReq* request, ::rp4::ParserLevelResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq* request, ::rp4::ModParserEntryResp* response, std::function<void(::grpc::Status)>) override;
      void modParserEntry(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq* request, ::rp4::ModParserEntryResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq* request, ::rp4::ClearParserResp* response, std::function<void(::grpc::Status)>) override;
      void clearParser(::grpc::ClientContext* context, const ::rp4::ClearParserReq* request, ::rp4::ClearParserResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void insertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq* request, ::rp4::InsertRelationExpResp* response, std::function<void(::grpc::Status)>) override;
      void insertRelationExp(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq* request, ::rp4::InsertRelationExpResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq* request, ::rp4::ClearRelationExpResp* response, std::function<void(::grpc::Status)>) override;
      void clearRelationExp(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq* request, ::rp4::ClearRelationExpResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq* request, ::rp4::ClearResMapResp* response, std::function<void(::grpc::Status)>) override;
      void clearResMap(::grpc::ClientContext* context, const ::rp4::ClearResMapReq* request, ::rp4::ClearResMapResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq* request, ::rp4::ModResMapResp* response, std::function<void(::grpc::Status)>) override;
      void modResMap(::grpc::ClientContext* context, const ::rp4::ModResMapReq* request, ::rp4::ModResMapResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq* request, ::rp4::SetDefaultGateEntryResp* response, std::function<void(::grpc::Status)>) override;
      void setDefaultGateEntry(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq* request, ::rp4::SetDefaultGateEntryResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq* request, ::rp4::SetNoTableResp* response, std::function<void(::grpc::Status)>) override;
      void setNoTable(::grpc::ClientContext* context, const ::rp4::SetNoTableReq* request, ::rp4::SetNoTableResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq* request, ::rp4::SetActionProcResp* response, std::function<void(::grpc::Status)>) override;
      void setActionProc(::grpc::ClientContext* context, const ::rp4::SetActionProcReq* request, ::rp4::SetActionProcResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq* request, ::rp4::SetMemConfigResp* response, std::function<void(::grpc::Status)>) override;
      void setMemConfig(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq* request, ::rp4::SetMemConfigResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq* request, ::rp4::SetFieldInfoResp* response, std::function<void(::grpc::Status)>) override;
      void setFieldInfo(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq* request, ::rp4::SetFieldInfoResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq* request, ::rp4::ClearOldConfigResp* response, std::function<void(::grpc::Status)>) override;
      void clearOldConfig(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq* request, ::rp4::ClearOldConfigResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq* request, ::rp4::SetMissActIdResp* response, std::function<void(::grpc::Status)>) override;
      void setMissActId(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq* request, ::rp4::SetMissActIdResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void insertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq* request, ::rp4::InsertSramEntryResp* response, std::function<void(::grpc::Status)>) override;
      void insertSramEntry(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq* request, ::rp4::InsertSramEntryResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void insertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq* request, ::rp4::InsertTcamEntryResp* response, std::function<void(::grpc::Status)>) override;
      void insertTcamEntry(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq* request, ::rp4::InsertTcamEntryResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void insertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq* request, ::rp4::InsertActionResp* response, std::function<void(::grpc::Status)>) override;
      void insertAction(::grpc::ClientContext* context, const ::rp4::InsertActionReq* request, ::rp4::InsertActionResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq* request, ::rp4::ClearActionResp* response, std::function<void(::grpc::Status)>) override;
      void clearAction(::grpc::ClientContext* context, const ::rp4::ClearActionReq* request, ::rp4::ClearActionResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      void delAction(::grpc::ClientContext* context, const ::rp4::DelActionReq* request, ::rp4::DelActionResp* response, std::function<void(::grpc::Status)>) override;
      void delAction(::grpc::ClientContext* context, const ::rp4::DelActionReq* request, ::rp4::DelActionResp* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::rp4::SetMetadataResp>* AsyncsetMetadataRaw(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetMetadataResp>* PrepareAsyncsetMetadataRaw(::grpc::ClientContext* context, const ::rp4::SetMetadataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ParserLevelResp>* AsyncinitParserLevelRaw(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ParserLevelResp>* PrepareAsyncinitParserLevelRaw(::grpc::ClientContext* context, const ::rp4::ParserLevelReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ModParserEntryResp>* AsyncmodParserEntryRaw(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ModParserEntryResp>* PrepareAsyncmodParserEntryRaw(::grpc::ClientContext* context, const ::rp4::ModParserEntryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearParserResp>* AsyncclearParserRaw(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearParserResp>* PrepareAsyncclearParserRaw(::grpc::ClientContext* context, const ::rp4::ClearParserReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::InsertRelationExpResp>* AsyncinsertRelationExpRaw(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::InsertRelationExpResp>* PrepareAsyncinsertRelationExpRaw(::grpc::ClientContext* context, const ::rp4::InsertRelationExpReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearRelationExpResp>* AsyncclearRelationExpRaw(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearRelationExpResp>* PrepareAsyncclearRelationExpRaw(::grpc::ClientContext* context, const ::rp4::ClearRelationExpReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearResMapResp>* AsyncclearResMapRaw(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearResMapResp>* PrepareAsyncclearResMapRaw(::grpc::ClientContext* context, const ::rp4::ClearResMapReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ModResMapResp>* AsyncmodResMapRaw(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ModResMapResp>* PrepareAsyncmodResMapRaw(::grpc::ClientContext* context, const ::rp4::ModResMapReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetDefaultGateEntryResp>* AsyncsetDefaultGateEntryRaw(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetDefaultGateEntryResp>* PrepareAsyncsetDefaultGateEntryRaw(::grpc::ClientContext* context, const ::rp4::SetDefaultGateEntryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetNoTableResp>* AsyncsetNoTableRaw(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetNoTableResp>* PrepareAsyncsetNoTableRaw(::grpc::ClientContext* context, const ::rp4::SetNoTableReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetActionProcResp>* AsyncsetActionProcRaw(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetActionProcResp>* PrepareAsyncsetActionProcRaw(::grpc::ClientContext* context, const ::rp4::SetActionProcReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetMemConfigResp>* AsyncsetMemConfigRaw(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetMemConfigResp>* PrepareAsyncsetMemConfigRaw(::grpc::ClientContext* context, const ::rp4::SetMemConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetFieldInfoResp>* AsyncsetFieldInfoRaw(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetFieldInfoResp>* PrepareAsyncsetFieldInfoRaw(::grpc::ClientContext* context, const ::rp4::SetFieldInfoReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearOldConfigResp>* AsyncclearOldConfigRaw(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearOldConfigResp>* PrepareAsyncclearOldConfigRaw(::grpc::ClientContext* context, const ::rp4::ClearOldConfigReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetMissActIdResp>* AsyncsetMissActIdRaw(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::SetMissActIdResp>* PrepareAsyncsetMissActIdRaw(::grpc::ClientContext* context, const ::rp4::SetMissActIdReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::InsertSramEntryResp>* AsyncinsertSramEntryRaw(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::InsertSramEntryResp>* PrepareAsyncinsertSramEntryRaw(::grpc::ClientContext* context, const ::rp4::InsertSramEntryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::InsertTcamEntryResp>* AsyncinsertTcamEntryRaw(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::InsertTcamEntryResp>* PrepareAsyncinsertTcamEntryRaw(::grpc::ClientContext* context, const ::rp4::InsertTcamEntryReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::InsertActionResp>* AsyncinsertActionRaw(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::InsertActionResp>* PrepareAsyncinsertActionRaw(::grpc::ClientContext* context, const ::rp4::InsertActionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearActionResp>* AsyncclearActionRaw(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::ClearActionResp>* PrepareAsyncclearActionRaw(::grpc::ClientContext* context, const ::rp4::ClearActionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::DelActionResp>* AsyncdelActionRaw(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rp4::DelActionResp>* PrepareAsyncdelActionRaw(::grpc::ClientContext* context, const ::rp4::DelActionReq& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_setMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_initParserLevel_;
    const ::grpc::internal::RpcMethod rpcmethod_modParserEntry_;
    const ::grpc::internal::RpcMethod rpcmethod_clearParser_;
    const ::grpc::internal::RpcMethod rpcmethod_insertRelationExp_;
    const ::grpc::internal::RpcMethod rpcmethod_clearRelationExp_;
    const ::grpc::internal::RpcMethod rpcmethod_clearResMap_;
    const ::grpc::internal::RpcMethod rpcmethod_modResMap_;
    const ::grpc::internal::RpcMethod rpcmethod_setDefaultGateEntry_;
    const ::grpc::internal::RpcMethod rpcmethod_setNoTable_;
    const ::grpc::internal::RpcMethod rpcmethod_setActionProc_;
    const ::grpc::internal::RpcMethod rpcmethod_setMemConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_setFieldInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_clearOldConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_setMissActId_;
    const ::grpc::internal::RpcMethod rpcmethod_insertSramEntry_;
    const ::grpc::internal::RpcMethod rpcmethod_insertTcamEntry_;
    const ::grpc::internal::RpcMethod rpcmethod_insertAction_;
    const ::grpc::internal::RpcMethod rpcmethod_clearAction_;
    const ::grpc::internal::RpcMethod rpcmethod_delAction_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // ***** metadata ****
    virtual ::grpc::Status setMetadata(::grpc::ServerContext* context, const ::rp4::SetMetadataReq* request, ::rp4::SetMetadataResp* response);
    // **** parser ****
    virtual ::grpc::Status initParserLevel(::grpc::ServerContext* context, const ::rp4::ParserLevelReq* request, ::rp4::ParserLevelResp* response);
    virtual ::grpc::Status modParserEntry(::grpc::ServerContext* context, const ::rp4::ModParserEntryReq* request, ::rp4::ModParserEntryResp* response);
    virtual ::grpc::Status clearParser(::grpc::ServerContext* context, const ::rp4::ClearParserReq* request, ::rp4::ClearParserResp* response);
    // **** gateway ****
    virtual ::grpc::Status insertRelationExp(::grpc::ServerContext* context, const ::rp4::InsertRelationExpReq* request, ::rp4::InsertRelationExpResp* response);
    virtual ::grpc::Status clearRelationExp(::grpc::ServerContext* context, const ::rp4::ClearRelationExpReq* request, ::rp4::ClearRelationExpResp* response);
    virtual ::grpc::Status clearResMap(::grpc::ServerContext* context, const ::rp4::ClearResMapReq* request, ::rp4::ClearResMapResp* response);
    virtual ::grpc::Status modResMap(::grpc::ServerContext* context, const ::rp4::ModResMapReq* request, ::rp4::ModResMapResp* response);
    virtual ::grpc::Status setDefaultGateEntry(::grpc::ServerContext* context, const ::rp4::SetDefaultGateEntryReq* request, ::rp4::SetDefaultGateEntryResp* response);
    // ***** matcher ******
    virtual ::grpc::Status setNoTable(::grpc::ServerContext* context, const ::rp4::SetNoTableReq* request, ::rp4::SetNoTableResp* response);
    virtual ::grpc::Status setActionProc(::grpc::ServerContext* context, const ::rp4::SetActionProcReq* request, ::rp4::SetActionProcResp* response);
    virtual ::grpc::Status setMemConfig(::grpc::ServerContext* context, const ::rp4::SetMemConfigReq* request, ::rp4::SetMemConfigResp* response);
    virtual ::grpc::Status setFieldInfo(::grpc::ServerContext* context, const ::rp4::SetFieldInfoReq* request, ::rp4::SetFieldInfoResp* response);
    //  rpc setHitMissBitmap (SetHitMissBitmapReq) returns (SetHitMissBitmapResp);
    virtual ::grpc::Status clearOldConfig(::grpc::ServerContext* context, const ::rp4::ClearOldConfigReq* request, ::rp4::ClearOldConfigResp* response);
    //  rpc setHitActId (SetHitActIdReq) returns (SetHitActIdResp);
    virtual ::grpc::Status setMissActId(::grpc::ServerContext* context, const ::rp4::SetMissActIdReq* request, ::rp4::SetMissActIdResp* response);
    // table entry
    virtual ::grpc::Status insertSramEntry(::grpc::ServerContext* context, const ::rp4::InsertSramEntryReq* request, ::rp4::InsertSramEntryResp* response);
    virtual ::grpc::Status insertTcamEntry(::grpc::ServerContext* context, const ::rp4::InsertTcamEntryReq* request, ::rp4::InsertTcamEntryResp* response);
    // ***** executor ******
    virtual ::grpc::Status insertAction(::grpc::ServerContext* context, const ::rp4::InsertActionReq* request, ::rp4::InsertActionResp* response);
    virtual ::grpc::Status clearAction(::grpc::ServerContext* context, const ::rp4::ClearActionReq* request, ::rp4::ClearActionResp* response);
    virtual ::grpc::Status delAction(::grpc::ServerContext* context, const ::rp4::DelActionReq* request, ::rp4::DelActionResp* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_setMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setMetadata() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_setMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMetadata(::grpc::ServerContext* /*context*/, const ::rp4::SetMetadataReq* /*request*/, ::rp4::SetMetadataResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetMetadata(::grpc::ServerContext* context, ::rp4::SetMetadataReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::SetMetadataResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_initParserLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_initParserLevel() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_initParserLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initParserLevel(::grpc::ServerContext* /*context*/, const ::rp4::ParserLevelReq* /*request*/, ::rp4::ParserLevelResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinitParserLevel(::grpc::ServerContext* context, ::rp4::ParserLevelReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::ParserLevelResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modParserEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modParserEntry() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_modParserEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modParserEntry(::grpc::ServerContext* /*context*/, const ::rp4::ModParserEntryReq* /*request*/, ::rp4::ModParserEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodParserEntry(::grpc::ServerContext* context, ::rp4::ModParserEntryReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::ModParserEntryResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clearParser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clearParser() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_clearParser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearParser(::grpc::ServerContext* /*context*/, const ::rp4::ClearParserReq* /*request*/, ::rp4::ClearParserResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearParser(::grpc::ServerContext* context, ::rp4::ClearParserReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::ClearParserResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insertRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_insertRelationExp() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_insertRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::InsertRelationExpReq* /*request*/, ::rp4::InsertRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinsertRelationExp(::grpc::ServerContext* context, ::rp4::InsertRelationExpReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::InsertRelationExpResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clearRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clearRelationExp() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_clearRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::ClearRelationExpReq* /*request*/, ::rp4::ClearRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearRelationExp(::grpc::ServerContext* context, ::rp4::ClearRelationExpReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::ClearRelationExpResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clearResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clearResMap() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_clearResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearResMap(::grpc::ServerContext* /*context*/, const ::rp4::ClearResMapReq* /*request*/, ::rp4::ClearResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearResMap(::grpc::ServerContext* context, ::rp4::ClearResMapReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::ClearResMapResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modResMap() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_modResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modResMap(::grpc::ServerContext* /*context*/, const ::rp4::ModResMapReq* /*request*/, ::rp4::ModResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodResMap(::grpc::ServerContext* context, ::rp4::ModResMapReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::ModResMapResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setDefaultGateEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setDefaultGateEntry() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_setDefaultGateEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDefaultGateEntry(::grpc::ServerContext* /*context*/, const ::rp4::SetDefaultGateEntryReq* /*request*/, ::rp4::SetDefaultGateEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetDefaultGateEntry(::grpc::ServerContext* context, ::rp4::SetDefaultGateEntryReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::SetDefaultGateEntryResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setNoTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setNoTable() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_setNoTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setNoTable(::grpc::ServerContext* /*context*/, const ::rp4::SetNoTableReq* /*request*/, ::rp4::SetNoTableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetNoTable(::grpc::ServerContext* context, ::rp4::SetNoTableReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::SetNoTableResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setActionProc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setActionProc() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_setActionProc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setActionProc(::grpc::ServerContext* /*context*/, const ::rp4::SetActionProcReq* /*request*/, ::rp4::SetActionProcResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetActionProc(::grpc::ServerContext* context, ::rp4::SetActionProcReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::SetActionProcResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setMemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setMemConfig() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_setMemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMemConfig(::grpc::ServerContext* /*context*/, const ::rp4::SetMemConfigReq* /*request*/, ::rp4::SetMemConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetMemConfig(::grpc::ServerContext* context, ::rp4::SetMemConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::SetMemConfigResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setFieldInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setFieldInfo() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_setFieldInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFieldInfo(::grpc::ServerContext* /*context*/, const ::rp4::SetFieldInfoReq* /*request*/, ::rp4::SetFieldInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetFieldInfo(::grpc::ServerContext* context, ::rp4::SetFieldInfoReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::SetFieldInfoResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clearOldConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clearOldConfig() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_clearOldConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearOldConfig(::grpc::ServerContext* /*context*/, const ::rp4::ClearOldConfigReq* /*request*/, ::rp4::ClearOldConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearOldConfig(::grpc::ServerContext* context, ::rp4::ClearOldConfigReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::ClearOldConfigResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setMissActId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setMissActId() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_setMissActId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMissActId(::grpc::ServerContext* /*context*/, const ::rp4::SetMissActIdReq* /*request*/, ::rp4::SetMissActIdResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetMissActId(::grpc::ServerContext* context, ::rp4::SetMissActIdReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::SetMissActIdResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insertSramEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_insertSramEntry() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_insertSramEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertSramEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertSramEntryReq* /*request*/, ::rp4::InsertSramEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinsertSramEntry(::grpc::ServerContext* context, ::rp4::InsertSramEntryReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::InsertSramEntryResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insertTcamEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_insertTcamEntry() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_insertTcamEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertTcamEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertTcamEntryReq* /*request*/, ::rp4::InsertTcamEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinsertTcamEntry(::grpc::ServerContext* context, ::rp4::InsertTcamEntryReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::InsertTcamEntryResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_insertAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_insertAction() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_insertAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertAction(::grpc::ServerContext* /*context*/, const ::rp4::InsertActionReq* /*request*/, ::rp4::InsertActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinsertAction(::grpc::ServerContext* context, ::rp4::InsertActionReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::InsertActionResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clearAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clearAction() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_clearAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearAction(::grpc::ServerContext* /*context*/, const ::rp4::ClearActionReq* /*request*/, ::rp4::ClearActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearAction(::grpc::ServerContext* context, ::rp4::ClearActionReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::ClearActionResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_delAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_delAction() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_delAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delAction(::grpc::ServerContext* /*context*/, const ::rp4::DelActionReq* /*request*/, ::rp4::DelActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdelAction(::grpc::ServerContext* context, ::rp4::DelActionReq* request, ::grpc::ServerAsyncResponseWriter< ::rp4::DelActionResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_setMetadata<WithAsyncMethod_initParserLevel<WithAsyncMethod_modParserEntry<WithAsyncMethod_clearParser<WithAsyncMethod_insertRelationExp<WithAsyncMethod_clearRelationExp<WithAsyncMethod_clearResMap<WithAsyncMethod_modResMap<WithAsyncMethod_setDefaultGateEntry<WithAsyncMethod_setNoTable<WithAsyncMethod_setActionProc<WithAsyncMethod_setMemConfig<WithAsyncMethod_setFieldInfo<WithAsyncMethod_clearOldConfig<WithAsyncMethod_setMissActId<WithAsyncMethod_insertSramEntry<WithAsyncMethod_insertTcamEntry<WithAsyncMethod_insertAction<WithAsyncMethod_clearAction<WithAsyncMethod_delAction<Service > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_setMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setMetadata() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::SetMetadataReq, ::rp4::SetMetadataResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::SetMetadataReq* request, ::rp4::SetMetadataResp* response) { return this->setMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_setMetadata(
        ::grpc::MessageAllocator< ::rp4::SetMetadataReq, ::rp4::SetMetadataResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::SetMetadataReq, ::rp4::SetMetadataResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMetadata(::grpc::ServerContext* /*context*/, const ::rp4::SetMetadataReq* /*request*/, ::rp4::SetMetadataResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::SetMetadataReq* /*request*/, ::rp4::SetMetadataResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_initParserLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_initParserLevel() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::ParserLevelReq, ::rp4::ParserLevelResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::ParserLevelReq* request, ::rp4::ParserLevelResp* response) { return this->initParserLevel(context, request, response); }));}
    void SetMessageAllocatorFor_initParserLevel(
        ::grpc::MessageAllocator< ::rp4::ParserLevelReq, ::rp4::ParserLevelResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::ParserLevelReq, ::rp4::ParserLevelResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_initParserLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initParserLevel(::grpc::ServerContext* /*context*/, const ::rp4::ParserLevelReq* /*request*/, ::rp4::ParserLevelResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* initParserLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::ParserLevelReq* /*request*/, ::rp4::ParserLevelResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modParserEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modParserEntry() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::ModParserEntryReq, ::rp4::ModParserEntryResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::ModParserEntryReq* request, ::rp4::ModParserEntryResp* response) { return this->modParserEntry(context, request, response); }));}
    void SetMessageAllocatorFor_modParserEntry(
        ::grpc::MessageAllocator< ::rp4::ModParserEntryReq, ::rp4::ModParserEntryResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::ModParserEntryReq, ::rp4::ModParserEntryResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modParserEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modParserEntry(::grpc::ServerContext* /*context*/, const ::rp4::ModParserEntryReq* /*request*/, ::rp4::ModParserEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modParserEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::ModParserEntryReq* /*request*/, ::rp4::ModParserEntryResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clearParser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clearParser() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::ClearParserReq, ::rp4::ClearParserResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::ClearParserReq* request, ::rp4::ClearParserResp* response) { return this->clearParser(context, request, response); }));}
    void SetMessageAllocatorFor_clearParser(
        ::grpc::MessageAllocator< ::rp4::ClearParserReq, ::rp4::ClearParserResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::ClearParserReq, ::rp4::ClearParserResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clearParser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearParser(::grpc::ServerContext* /*context*/, const ::rp4::ClearParserReq* /*request*/, ::rp4::ClearParserResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearParser(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::ClearParserReq* /*request*/, ::rp4::ClearParserResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_insertRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_insertRelationExp() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::InsertRelationExpReq, ::rp4::InsertRelationExpResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::InsertRelationExpReq* request, ::rp4::InsertRelationExpResp* response) { return this->insertRelationExp(context, request, response); }));}
    void SetMessageAllocatorFor_insertRelationExp(
        ::grpc::MessageAllocator< ::rp4::InsertRelationExpReq, ::rp4::InsertRelationExpResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::InsertRelationExpReq, ::rp4::InsertRelationExpResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_insertRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::InsertRelationExpReq* /*request*/, ::rp4::InsertRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* insertRelationExp(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::InsertRelationExpReq* /*request*/, ::rp4::InsertRelationExpResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clearRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clearRelationExp() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::ClearRelationExpReq, ::rp4::ClearRelationExpResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::ClearRelationExpReq* request, ::rp4::ClearRelationExpResp* response) { return this->clearRelationExp(context, request, response); }));}
    void SetMessageAllocatorFor_clearRelationExp(
        ::grpc::MessageAllocator< ::rp4::ClearRelationExpReq, ::rp4::ClearRelationExpResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::ClearRelationExpReq, ::rp4::ClearRelationExpResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clearRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::ClearRelationExpReq* /*request*/, ::rp4::ClearRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearRelationExp(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::ClearRelationExpReq* /*request*/, ::rp4::ClearRelationExpResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clearResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clearResMap() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::ClearResMapReq, ::rp4::ClearResMapResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::ClearResMapReq* request, ::rp4::ClearResMapResp* response) { return this->clearResMap(context, request, response); }));}
    void SetMessageAllocatorFor_clearResMap(
        ::grpc::MessageAllocator< ::rp4::ClearResMapReq, ::rp4::ClearResMapResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::ClearResMapReq, ::rp4::ClearResMapResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clearResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearResMap(::grpc::ServerContext* /*context*/, const ::rp4::ClearResMapReq* /*request*/, ::rp4::ClearResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearResMap(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::ClearResMapReq* /*request*/, ::rp4::ClearResMapResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modResMap() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::ModResMapReq, ::rp4::ModResMapResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::ModResMapReq* request, ::rp4::ModResMapResp* response) { return this->modResMap(context, request, response); }));}
    void SetMessageAllocatorFor_modResMap(
        ::grpc::MessageAllocator< ::rp4::ModResMapReq, ::rp4::ModResMapResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::ModResMapReq, ::rp4::ModResMapResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modResMap(::grpc::ServerContext* /*context*/, const ::rp4::ModResMapReq* /*request*/, ::rp4::ModResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modResMap(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::ModResMapReq* /*request*/, ::rp4::ModResMapResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setDefaultGateEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setDefaultGateEntry() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::SetDefaultGateEntryReq, ::rp4::SetDefaultGateEntryResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::SetDefaultGateEntryReq* request, ::rp4::SetDefaultGateEntryResp* response) { return this->setDefaultGateEntry(context, request, response); }));}
    void SetMessageAllocatorFor_setDefaultGateEntry(
        ::grpc::MessageAllocator< ::rp4::SetDefaultGateEntryReq, ::rp4::SetDefaultGateEntryResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::SetDefaultGateEntryReq, ::rp4::SetDefaultGateEntryResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setDefaultGateEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDefaultGateEntry(::grpc::ServerContext* /*context*/, const ::rp4::SetDefaultGateEntryReq* /*request*/, ::rp4::SetDefaultGateEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setDefaultGateEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::SetDefaultGateEntryReq* /*request*/, ::rp4::SetDefaultGateEntryResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setNoTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setNoTable() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::SetNoTableReq, ::rp4::SetNoTableResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::SetNoTableReq* request, ::rp4::SetNoTableResp* response) { return this->setNoTable(context, request, response); }));}
    void SetMessageAllocatorFor_setNoTable(
        ::grpc::MessageAllocator< ::rp4::SetNoTableReq, ::rp4::SetNoTableResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::SetNoTableReq, ::rp4::SetNoTableResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setNoTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setNoTable(::grpc::ServerContext* /*context*/, const ::rp4::SetNoTableReq* /*request*/, ::rp4::SetNoTableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setNoTable(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::SetNoTableReq* /*request*/, ::rp4::SetNoTableResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setActionProc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setActionProc() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::SetActionProcReq, ::rp4::SetActionProcResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::SetActionProcReq* request, ::rp4::SetActionProcResp* response) { return this->setActionProc(context, request, response); }));}
    void SetMessageAllocatorFor_setActionProc(
        ::grpc::MessageAllocator< ::rp4::SetActionProcReq, ::rp4::SetActionProcResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::SetActionProcReq, ::rp4::SetActionProcResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setActionProc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setActionProc(::grpc::ServerContext* /*context*/, const ::rp4::SetActionProcReq* /*request*/, ::rp4::SetActionProcResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setActionProc(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::SetActionProcReq* /*request*/, ::rp4::SetActionProcResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setMemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setMemConfig() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::SetMemConfigReq, ::rp4::SetMemConfigResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::SetMemConfigReq* request, ::rp4::SetMemConfigResp* response) { return this->setMemConfig(context, request, response); }));}
    void SetMessageAllocatorFor_setMemConfig(
        ::grpc::MessageAllocator< ::rp4::SetMemConfigReq, ::rp4::SetMemConfigResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::SetMemConfigReq, ::rp4::SetMemConfigResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setMemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMemConfig(::grpc::ServerContext* /*context*/, const ::rp4::SetMemConfigReq* /*request*/, ::rp4::SetMemConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setMemConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::SetMemConfigReq* /*request*/, ::rp4::SetMemConfigResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setFieldInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setFieldInfo() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::SetFieldInfoReq, ::rp4::SetFieldInfoResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::SetFieldInfoReq* request, ::rp4::SetFieldInfoResp* response) { return this->setFieldInfo(context, request, response); }));}
    void SetMessageAllocatorFor_setFieldInfo(
        ::grpc::MessageAllocator< ::rp4::SetFieldInfoReq, ::rp4::SetFieldInfoResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::SetFieldInfoReq, ::rp4::SetFieldInfoResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setFieldInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFieldInfo(::grpc::ServerContext* /*context*/, const ::rp4::SetFieldInfoReq* /*request*/, ::rp4::SetFieldInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setFieldInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::SetFieldInfoReq* /*request*/, ::rp4::SetFieldInfoResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clearOldConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clearOldConfig() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::ClearOldConfigReq, ::rp4::ClearOldConfigResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::ClearOldConfigReq* request, ::rp4::ClearOldConfigResp* response) { return this->clearOldConfig(context, request, response); }));}
    void SetMessageAllocatorFor_clearOldConfig(
        ::grpc::MessageAllocator< ::rp4::ClearOldConfigReq, ::rp4::ClearOldConfigResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::ClearOldConfigReq, ::rp4::ClearOldConfigResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clearOldConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearOldConfig(::grpc::ServerContext* /*context*/, const ::rp4::ClearOldConfigReq* /*request*/, ::rp4::ClearOldConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearOldConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::ClearOldConfigReq* /*request*/, ::rp4::ClearOldConfigResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setMissActId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setMissActId() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::SetMissActIdReq, ::rp4::SetMissActIdResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::SetMissActIdReq* request, ::rp4::SetMissActIdResp* response) { return this->setMissActId(context, request, response); }));}
    void SetMessageAllocatorFor_setMissActId(
        ::grpc::MessageAllocator< ::rp4::SetMissActIdReq, ::rp4::SetMissActIdResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::SetMissActIdReq, ::rp4::SetMissActIdResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setMissActId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMissActId(::grpc::ServerContext* /*context*/, const ::rp4::SetMissActIdReq* /*request*/, ::rp4::SetMissActIdResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setMissActId(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::SetMissActIdReq* /*request*/, ::rp4::SetMissActIdResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_insertSramEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_insertSramEntry() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::InsertSramEntryReq, ::rp4::InsertSramEntryResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::InsertSramEntryReq* request, ::rp4::InsertSramEntryResp* response) { return this->insertSramEntry(context, request, response); }));}
    void SetMessageAllocatorFor_insertSramEntry(
        ::grpc::MessageAllocator< ::rp4::InsertSramEntryReq, ::rp4::InsertSramEntryResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::InsertSramEntryReq, ::rp4::InsertSramEntryResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_insertSramEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertSramEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertSramEntryReq* /*request*/, ::rp4::InsertSramEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* insertSramEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::InsertSramEntryReq* /*request*/, ::rp4::InsertSramEntryResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_insertTcamEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_insertTcamEntry() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::InsertTcamEntryReq, ::rp4::InsertTcamEntryResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::InsertTcamEntryReq* request, ::rp4::InsertTcamEntryResp* response) { return this->insertTcamEntry(context, request, response); }));}
    void SetMessageAllocatorFor_insertTcamEntry(
        ::grpc::MessageAllocator< ::rp4::InsertTcamEntryReq, ::rp4::InsertTcamEntryResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::InsertTcamEntryReq, ::rp4::InsertTcamEntryResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_insertTcamEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertTcamEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertTcamEntryReq* /*request*/, ::rp4::InsertTcamEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* insertTcamEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::InsertTcamEntryReq* /*request*/, ::rp4::InsertTcamEntryResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_insertAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_insertAction() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::InsertActionReq, ::rp4::InsertActionResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::InsertActionReq* request, ::rp4::InsertActionResp* response) { return this->insertAction(context, request, response); }));}
    void SetMessageAllocatorFor_insertAction(
        ::grpc::MessageAllocator< ::rp4::InsertActionReq, ::rp4::InsertActionResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::InsertActionReq, ::rp4::InsertActionResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_insertAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertAction(::grpc::ServerContext* /*context*/, const ::rp4::InsertActionReq* /*request*/, ::rp4::InsertActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* insertAction(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::InsertActionReq* /*request*/, ::rp4::InsertActionResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clearAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clearAction() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::ClearActionReq, ::rp4::ClearActionResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::ClearActionReq* request, ::rp4::ClearActionResp* response) { return this->clearAction(context, request, response); }));}
    void SetMessageAllocatorFor_clearAction(
        ::grpc::MessageAllocator< ::rp4::ClearActionReq, ::rp4::ClearActionResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::ClearActionReq, ::rp4::ClearActionResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clearAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearAction(::grpc::ServerContext* /*context*/, const ::rp4::ClearActionReq* /*request*/, ::rp4::ClearActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearAction(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::ClearActionReq* /*request*/, ::rp4::ClearActionResp* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_delAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_delAction() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::rp4::DelActionReq, ::rp4::DelActionResp>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rp4::DelActionReq* request, ::rp4::DelActionResp* response) { return this->delAction(context, request, response); }));}
    void SetMessageAllocatorFor_delAction(
        ::grpc::MessageAllocator< ::rp4::DelActionReq, ::rp4::DelActionResp>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rp4::DelActionReq, ::rp4::DelActionResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_delAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delAction(::grpc::ServerContext* /*context*/, const ::rp4::DelActionReq* /*request*/, ::rp4::DelActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delAction(
      ::grpc::CallbackServerContext* /*context*/, const ::rp4::DelActionReq* /*request*/, ::rp4::DelActionResp* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_setMetadata<WithCallbackMethod_initParserLevel<WithCallbackMethod_modParserEntry<WithCallbackMethod_clearParser<WithCallbackMethod_insertRelationExp<WithCallbackMethod_clearRelationExp<WithCallbackMethod_clearResMap<WithCallbackMethod_modResMap<WithCallbackMethod_setDefaultGateEntry<WithCallbackMethod_setNoTable<WithCallbackMethod_setActionProc<WithCallbackMethod_setMemConfig<WithCallbackMethod_setFieldInfo<WithCallbackMethod_clearOldConfig<WithCallbackMethod_setMissActId<WithCallbackMethod_insertSramEntry<WithCallbackMethod_insertTcamEntry<WithCallbackMethod_insertAction<WithCallbackMethod_clearAction<WithCallbackMethod_delAction<Service > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_setMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setMetadata() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_setMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMetadata(::grpc::ServerContext* /*context*/, const ::rp4::SetMetadataReq* /*request*/, ::rp4::SetMetadataResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_initParserLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_initParserLevel() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_initParserLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initParserLevel(::grpc::ServerContext* /*context*/, const ::rp4::ParserLevelReq* /*request*/, ::rp4::ParserLevelResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modParserEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modParserEntry() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_modParserEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modParserEntry(::grpc::ServerContext* /*context*/, const ::rp4::ModParserEntryReq* /*request*/, ::rp4::ModParserEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clearParser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clearParser() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_clearParser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearParser(::grpc::ServerContext* /*context*/, const ::rp4::ClearParserReq* /*request*/, ::rp4::ClearParserResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insertRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_insertRelationExp() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_insertRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::InsertRelationExpReq* /*request*/, ::rp4::InsertRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clearRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clearRelationExp() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_clearRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::ClearRelationExpReq* /*request*/, ::rp4::ClearRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clearResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clearResMap() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_clearResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearResMap(::grpc::ServerContext* /*context*/, const ::rp4::ClearResMapReq* /*request*/, ::rp4::ClearResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modResMap() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_modResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modResMap(::grpc::ServerContext* /*context*/, const ::rp4::ModResMapReq* /*request*/, ::rp4::ModResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setDefaultGateEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setDefaultGateEntry() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_setDefaultGateEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDefaultGateEntry(::grpc::ServerContext* /*context*/, const ::rp4::SetDefaultGateEntryReq* /*request*/, ::rp4::SetDefaultGateEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setNoTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setNoTable() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_setNoTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setNoTable(::grpc::ServerContext* /*context*/, const ::rp4::SetNoTableReq* /*request*/, ::rp4::SetNoTableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setActionProc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setActionProc() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_setActionProc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setActionProc(::grpc::ServerContext* /*context*/, const ::rp4::SetActionProcReq* /*request*/, ::rp4::SetActionProcResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setMemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setMemConfig() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_setMemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMemConfig(::grpc::ServerContext* /*context*/, const ::rp4::SetMemConfigReq* /*request*/, ::rp4::SetMemConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setFieldInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setFieldInfo() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_setFieldInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFieldInfo(::grpc::ServerContext* /*context*/, const ::rp4::SetFieldInfoReq* /*request*/, ::rp4::SetFieldInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clearOldConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clearOldConfig() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_clearOldConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearOldConfig(::grpc::ServerContext* /*context*/, const ::rp4::ClearOldConfigReq* /*request*/, ::rp4::ClearOldConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setMissActId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setMissActId() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_setMissActId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMissActId(::grpc::ServerContext* /*context*/, const ::rp4::SetMissActIdReq* /*request*/, ::rp4::SetMissActIdResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insertSramEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_insertSramEntry() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_insertSramEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertSramEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertSramEntryReq* /*request*/, ::rp4::InsertSramEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insertTcamEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_insertTcamEntry() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_insertTcamEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertTcamEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertTcamEntryReq* /*request*/, ::rp4::InsertTcamEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_insertAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_insertAction() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_insertAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertAction(::grpc::ServerContext* /*context*/, const ::rp4::InsertActionReq* /*request*/, ::rp4::InsertActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clearAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clearAction() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_clearAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearAction(::grpc::ServerContext* /*context*/, const ::rp4::ClearActionReq* /*request*/, ::rp4::ClearActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_delAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_delAction() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_delAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delAction(::grpc::ServerContext* /*context*/, const ::rp4::DelActionReq* /*request*/, ::rp4::DelActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_setMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setMetadata() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_setMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMetadata(::grpc::ServerContext* /*context*/, const ::rp4::SetMetadataReq* /*request*/, ::rp4::SetMetadataResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_initParserLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_initParserLevel() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_initParserLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initParserLevel(::grpc::ServerContext* /*context*/, const ::rp4::ParserLevelReq* /*request*/, ::rp4::ParserLevelResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinitParserLevel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modParserEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modParserEntry() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_modParserEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modParserEntry(::grpc::ServerContext* /*context*/, const ::rp4::ModParserEntryReq* /*request*/, ::rp4::ModParserEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodParserEntry(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clearParser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clearParser() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_clearParser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearParser(::grpc::ServerContext* /*context*/, const ::rp4::ClearParserReq* /*request*/, ::rp4::ClearParserResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearParser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insertRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_insertRelationExp() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_insertRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::InsertRelationExpReq* /*request*/, ::rp4::InsertRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinsertRelationExp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clearRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clearRelationExp() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_clearRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::ClearRelationExpReq* /*request*/, ::rp4::ClearRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearRelationExp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clearResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clearResMap() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_clearResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearResMap(::grpc::ServerContext* /*context*/, const ::rp4::ClearResMapReq* /*request*/, ::rp4::ClearResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearResMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modResMap() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_modResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modResMap(::grpc::ServerContext* /*context*/, const ::rp4::ModResMapReq* /*request*/, ::rp4::ModResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodResMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setDefaultGateEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setDefaultGateEntry() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_setDefaultGateEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDefaultGateEntry(::grpc::ServerContext* /*context*/, const ::rp4::SetDefaultGateEntryReq* /*request*/, ::rp4::SetDefaultGateEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetDefaultGateEntry(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setNoTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setNoTable() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_setNoTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setNoTable(::grpc::ServerContext* /*context*/, const ::rp4::SetNoTableReq* /*request*/, ::rp4::SetNoTableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetNoTable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setActionProc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setActionProc() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_setActionProc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setActionProc(::grpc::ServerContext* /*context*/, const ::rp4::SetActionProcReq* /*request*/, ::rp4::SetActionProcResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetActionProc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setMemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setMemConfig() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_setMemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMemConfig(::grpc::ServerContext* /*context*/, const ::rp4::SetMemConfigReq* /*request*/, ::rp4::SetMemConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetMemConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setFieldInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setFieldInfo() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_setFieldInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFieldInfo(::grpc::ServerContext* /*context*/, const ::rp4::SetFieldInfoReq* /*request*/, ::rp4::SetFieldInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetFieldInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clearOldConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clearOldConfig() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_clearOldConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearOldConfig(::grpc::ServerContext* /*context*/, const ::rp4::ClearOldConfigReq* /*request*/, ::rp4::ClearOldConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearOldConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setMissActId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setMissActId() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_setMissActId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMissActId(::grpc::ServerContext* /*context*/, const ::rp4::SetMissActIdReq* /*request*/, ::rp4::SetMissActIdResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetMissActId(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insertSramEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_insertSramEntry() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_insertSramEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertSramEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertSramEntryReq* /*request*/, ::rp4::InsertSramEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinsertSramEntry(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insertTcamEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_insertTcamEntry() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_insertTcamEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertTcamEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertTcamEntryReq* /*request*/, ::rp4::InsertTcamEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinsertTcamEntry(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_insertAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_insertAction() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_insertAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertAction(::grpc::ServerContext* /*context*/, const ::rp4::InsertActionReq* /*request*/, ::rp4::InsertActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestinsertAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clearAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clearAction() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_clearAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearAction(::grpc::ServerContext* /*context*/, const ::rp4::ClearActionReq* /*request*/, ::rp4::ClearActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclearAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_delAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_delAction() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_delAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delAction(::grpc::ServerContext* /*context*/, const ::rp4::DelActionReq* /*request*/, ::rp4::DelActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdelAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setMetadata() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_setMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMetadata(::grpc::ServerContext* /*context*/, const ::rp4::SetMetadataReq* /*request*/, ::rp4::SetMetadataResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_initParserLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_initParserLevel() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->initParserLevel(context, request, response); }));
    }
    ~WithRawCallbackMethod_initParserLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initParserLevel(::grpc::ServerContext* /*context*/, const ::rp4::ParserLevelReq* /*request*/, ::rp4::ParserLevelResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* initParserLevel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modParserEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modParserEntry() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modParserEntry(context, request, response); }));
    }
    ~WithRawCallbackMethod_modParserEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modParserEntry(::grpc::ServerContext* /*context*/, const ::rp4::ModParserEntryReq* /*request*/, ::rp4::ModParserEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modParserEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clearParser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clearParser() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clearParser(context, request, response); }));
    }
    ~WithRawCallbackMethod_clearParser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearParser(::grpc::ServerContext* /*context*/, const ::rp4::ClearParserReq* /*request*/, ::rp4::ClearParserResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearParser(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_insertRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_insertRelationExp() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->insertRelationExp(context, request, response); }));
    }
    ~WithRawCallbackMethod_insertRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::InsertRelationExpReq* /*request*/, ::rp4::InsertRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* insertRelationExp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clearRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clearRelationExp() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clearRelationExp(context, request, response); }));
    }
    ~WithRawCallbackMethod_clearRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::ClearRelationExpReq* /*request*/, ::rp4::ClearRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearRelationExp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clearResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clearResMap() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clearResMap(context, request, response); }));
    }
    ~WithRawCallbackMethod_clearResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearResMap(::grpc::ServerContext* /*context*/, const ::rp4::ClearResMapReq* /*request*/, ::rp4::ClearResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearResMap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modResMap() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modResMap(context, request, response); }));
    }
    ~WithRawCallbackMethod_modResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modResMap(::grpc::ServerContext* /*context*/, const ::rp4::ModResMapReq* /*request*/, ::rp4::ModResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modResMap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setDefaultGateEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setDefaultGateEntry() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setDefaultGateEntry(context, request, response); }));
    }
    ~WithRawCallbackMethod_setDefaultGateEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setDefaultGateEntry(::grpc::ServerContext* /*context*/, const ::rp4::SetDefaultGateEntryReq* /*request*/, ::rp4::SetDefaultGateEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setDefaultGateEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setNoTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setNoTable() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setNoTable(context, request, response); }));
    }
    ~WithRawCallbackMethod_setNoTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setNoTable(::grpc::ServerContext* /*context*/, const ::rp4::SetNoTableReq* /*request*/, ::rp4::SetNoTableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setNoTable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setActionProc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setActionProc() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setActionProc(context, request, response); }));
    }
    ~WithRawCallbackMethod_setActionProc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setActionProc(::grpc::ServerContext* /*context*/, const ::rp4::SetActionProcReq* /*request*/, ::rp4::SetActionProcResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setActionProc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setMemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setMemConfig() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setMemConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_setMemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMemConfig(::grpc::ServerContext* /*context*/, const ::rp4::SetMemConfigReq* /*request*/, ::rp4::SetMemConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setMemConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setFieldInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setFieldInfo() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setFieldInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_setFieldInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setFieldInfo(::grpc::ServerContext* /*context*/, const ::rp4::SetFieldInfoReq* /*request*/, ::rp4::SetFieldInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setFieldInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clearOldConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clearOldConfig() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clearOldConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_clearOldConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearOldConfig(::grpc::ServerContext* /*context*/, const ::rp4::ClearOldConfigReq* /*request*/, ::rp4::ClearOldConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearOldConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setMissActId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setMissActId() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setMissActId(context, request, response); }));
    }
    ~WithRawCallbackMethod_setMissActId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMissActId(::grpc::ServerContext* /*context*/, const ::rp4::SetMissActIdReq* /*request*/, ::rp4::SetMissActIdResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setMissActId(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_insertSramEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_insertSramEntry() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->insertSramEntry(context, request, response); }));
    }
    ~WithRawCallbackMethod_insertSramEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertSramEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertSramEntryReq* /*request*/, ::rp4::InsertSramEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* insertSramEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_insertTcamEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_insertTcamEntry() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->insertTcamEntry(context, request, response); }));
    }
    ~WithRawCallbackMethod_insertTcamEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertTcamEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertTcamEntryReq* /*request*/, ::rp4::InsertTcamEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* insertTcamEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_insertAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_insertAction() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->insertAction(context, request, response); }));
    }
    ~WithRawCallbackMethod_insertAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status insertAction(::grpc::ServerContext* /*context*/, const ::rp4::InsertActionReq* /*request*/, ::rp4::InsertActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* insertAction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clearAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clearAction() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clearAction(context, request, response); }));
    }
    ~WithRawCallbackMethod_clearAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clearAction(::grpc::ServerContext* /*context*/, const ::rp4::ClearActionReq* /*request*/, ::rp4::ClearActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clearAction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_delAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_delAction() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->delAction(context, request, response); }));
    }
    ~WithRawCallbackMethod_delAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delAction(::grpc::ServerContext* /*context*/, const ::rp4::DelActionReq* /*request*/, ::rp4::DelActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delAction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setMetadata() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::SetMetadataReq, ::rp4::SetMetadataResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::SetMetadataReq, ::rp4::SetMetadataResp>* streamer) {
                       return this->StreamedsetMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setMetadata(::grpc::ServerContext* /*context*/, const ::rp4::SetMetadataReq* /*request*/, ::rp4::SetMetadataResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::SetMetadataReq,::rp4::SetMetadataResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_initParserLevel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_initParserLevel() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::ParserLevelReq, ::rp4::ParserLevelResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::ParserLevelReq, ::rp4::ParserLevelResp>* streamer) {
                       return this->StreamedinitParserLevel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_initParserLevel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status initParserLevel(::grpc::ServerContext* /*context*/, const ::rp4::ParserLevelReq* /*request*/, ::rp4::ParserLevelResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedinitParserLevel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::ParserLevelReq,::rp4::ParserLevelResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modParserEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modParserEntry() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::ModParserEntryReq, ::rp4::ModParserEntryResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::ModParserEntryReq, ::rp4::ModParserEntryResp>* streamer) {
                       return this->StreamedmodParserEntry(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modParserEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modParserEntry(::grpc::ServerContext* /*context*/, const ::rp4::ModParserEntryReq* /*request*/, ::rp4::ModParserEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodParserEntry(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::ModParserEntryReq,::rp4::ModParserEntryResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clearParser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clearParser() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::ClearParserReq, ::rp4::ClearParserResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::ClearParserReq, ::rp4::ClearParserResp>* streamer) {
                       return this->StreamedclearParser(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clearParser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clearParser(::grpc::ServerContext* /*context*/, const ::rp4::ClearParserReq* /*request*/, ::rp4::ClearParserResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedclearParser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::ClearParserReq,::rp4::ClearParserResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insertRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_insertRelationExp() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::InsertRelationExpReq, ::rp4::InsertRelationExpResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::InsertRelationExpReq, ::rp4::InsertRelationExpResp>* streamer) {
                       return this->StreamedinsertRelationExp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_insertRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insertRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::InsertRelationExpReq* /*request*/, ::rp4::InsertRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedinsertRelationExp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::InsertRelationExpReq,::rp4::InsertRelationExpResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clearRelationExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clearRelationExp() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::ClearRelationExpReq, ::rp4::ClearRelationExpResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::ClearRelationExpReq, ::rp4::ClearRelationExpResp>* streamer) {
                       return this->StreamedclearRelationExp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clearRelationExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clearRelationExp(::grpc::ServerContext* /*context*/, const ::rp4::ClearRelationExpReq* /*request*/, ::rp4::ClearRelationExpResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedclearRelationExp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::ClearRelationExpReq,::rp4::ClearRelationExpResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clearResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clearResMap() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::ClearResMapReq, ::rp4::ClearResMapResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::ClearResMapReq, ::rp4::ClearResMapResp>* streamer) {
                       return this->StreamedclearResMap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clearResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clearResMap(::grpc::ServerContext* /*context*/, const ::rp4::ClearResMapReq* /*request*/, ::rp4::ClearResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedclearResMap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::ClearResMapReq,::rp4::ClearResMapResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modResMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modResMap() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::ModResMapReq, ::rp4::ModResMapResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::ModResMapReq, ::rp4::ModResMapResp>* streamer) {
                       return this->StreamedmodResMap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modResMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modResMap(::grpc::ServerContext* /*context*/, const ::rp4::ModResMapReq* /*request*/, ::rp4::ModResMapResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodResMap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::ModResMapReq,::rp4::ModResMapResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setDefaultGateEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setDefaultGateEntry() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::SetDefaultGateEntryReq, ::rp4::SetDefaultGateEntryResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::SetDefaultGateEntryReq, ::rp4::SetDefaultGateEntryResp>* streamer) {
                       return this->StreamedsetDefaultGateEntry(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setDefaultGateEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setDefaultGateEntry(::grpc::ServerContext* /*context*/, const ::rp4::SetDefaultGateEntryReq* /*request*/, ::rp4::SetDefaultGateEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetDefaultGateEntry(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::SetDefaultGateEntryReq,::rp4::SetDefaultGateEntryResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setNoTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setNoTable() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::SetNoTableReq, ::rp4::SetNoTableResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::SetNoTableReq, ::rp4::SetNoTableResp>* streamer) {
                       return this->StreamedsetNoTable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setNoTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setNoTable(::grpc::ServerContext* /*context*/, const ::rp4::SetNoTableReq* /*request*/, ::rp4::SetNoTableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetNoTable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::SetNoTableReq,::rp4::SetNoTableResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setActionProc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setActionProc() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::SetActionProcReq, ::rp4::SetActionProcResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::SetActionProcReq, ::rp4::SetActionProcResp>* streamer) {
                       return this->StreamedsetActionProc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setActionProc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setActionProc(::grpc::ServerContext* /*context*/, const ::rp4::SetActionProcReq* /*request*/, ::rp4::SetActionProcResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetActionProc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::SetActionProcReq,::rp4::SetActionProcResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setMemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setMemConfig() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::SetMemConfigReq, ::rp4::SetMemConfigResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::SetMemConfigReq, ::rp4::SetMemConfigResp>* streamer) {
                       return this->StreamedsetMemConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setMemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setMemConfig(::grpc::ServerContext* /*context*/, const ::rp4::SetMemConfigReq* /*request*/, ::rp4::SetMemConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetMemConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::SetMemConfigReq,::rp4::SetMemConfigResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setFieldInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setFieldInfo() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::SetFieldInfoReq, ::rp4::SetFieldInfoResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::SetFieldInfoReq, ::rp4::SetFieldInfoResp>* streamer) {
                       return this->StreamedsetFieldInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setFieldInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setFieldInfo(::grpc::ServerContext* /*context*/, const ::rp4::SetFieldInfoReq* /*request*/, ::rp4::SetFieldInfoResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetFieldInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::SetFieldInfoReq,::rp4::SetFieldInfoResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clearOldConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clearOldConfig() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::ClearOldConfigReq, ::rp4::ClearOldConfigResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::ClearOldConfigReq, ::rp4::ClearOldConfigResp>* streamer) {
                       return this->StreamedclearOldConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clearOldConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clearOldConfig(::grpc::ServerContext* /*context*/, const ::rp4::ClearOldConfigReq* /*request*/, ::rp4::ClearOldConfigResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedclearOldConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::ClearOldConfigReq,::rp4::ClearOldConfigResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setMissActId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setMissActId() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::SetMissActIdReq, ::rp4::SetMissActIdResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::SetMissActIdReq, ::rp4::SetMissActIdResp>* streamer) {
                       return this->StreamedsetMissActId(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setMissActId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setMissActId(::grpc::ServerContext* /*context*/, const ::rp4::SetMissActIdReq* /*request*/, ::rp4::SetMissActIdResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetMissActId(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::SetMissActIdReq,::rp4::SetMissActIdResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insertSramEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_insertSramEntry() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::InsertSramEntryReq, ::rp4::InsertSramEntryResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::InsertSramEntryReq, ::rp4::InsertSramEntryResp>* streamer) {
                       return this->StreamedinsertSramEntry(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_insertSramEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insertSramEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertSramEntryReq* /*request*/, ::rp4::InsertSramEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedinsertSramEntry(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::InsertSramEntryReq,::rp4::InsertSramEntryResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insertTcamEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_insertTcamEntry() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::InsertTcamEntryReq, ::rp4::InsertTcamEntryResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::InsertTcamEntryReq, ::rp4::InsertTcamEntryResp>* streamer) {
                       return this->StreamedinsertTcamEntry(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_insertTcamEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insertTcamEntry(::grpc::ServerContext* /*context*/, const ::rp4::InsertTcamEntryReq* /*request*/, ::rp4::InsertTcamEntryResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedinsertTcamEntry(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::InsertTcamEntryReq,::rp4::InsertTcamEntryResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_insertAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_insertAction() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::InsertActionReq, ::rp4::InsertActionResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::InsertActionReq, ::rp4::InsertActionResp>* streamer) {
                       return this->StreamedinsertAction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_insertAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status insertAction(::grpc::ServerContext* /*context*/, const ::rp4::InsertActionReq* /*request*/, ::rp4::InsertActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedinsertAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::InsertActionReq,::rp4::InsertActionResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clearAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clearAction() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::ClearActionReq, ::rp4::ClearActionResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::ClearActionReq, ::rp4::ClearActionResp>* streamer) {
                       return this->StreamedclearAction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clearAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clearAction(::grpc::ServerContext* /*context*/, const ::rp4::ClearActionReq* /*request*/, ::rp4::ClearActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedclearAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::ClearActionReq,::rp4::ClearActionResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_delAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_delAction() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rp4::DelActionReq, ::rp4::DelActionResp>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rp4::DelActionReq, ::rp4::DelActionResp>* streamer) {
                       return this->StreameddelAction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_delAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status delAction(::grpc::ServerContext* /*context*/, const ::rp4::DelActionReq* /*request*/, ::rp4::DelActionResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddelAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rp4::DelActionReq,::rp4::DelActionResp>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_setMetadata<WithStreamedUnaryMethod_initParserLevel<WithStreamedUnaryMethod_modParserEntry<WithStreamedUnaryMethod_clearParser<WithStreamedUnaryMethod_insertRelationExp<WithStreamedUnaryMethod_clearRelationExp<WithStreamedUnaryMethod_clearResMap<WithStreamedUnaryMethod_modResMap<WithStreamedUnaryMethod_setDefaultGateEntry<WithStreamedUnaryMethod_setNoTable<WithStreamedUnaryMethod_setActionProc<WithStreamedUnaryMethod_setMemConfig<WithStreamedUnaryMethod_setFieldInfo<WithStreamedUnaryMethod_clearOldConfig<WithStreamedUnaryMethod_setMissActId<WithStreamedUnaryMethod_insertSramEntry<WithStreamedUnaryMethod_insertTcamEntry<WithStreamedUnaryMethod_insertAction<WithStreamedUnaryMethod_clearAction<WithStreamedUnaryMethod_delAction<Service > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_setMetadata<WithStreamedUnaryMethod_initParserLevel<WithStreamedUnaryMethod_modParserEntry<WithStreamedUnaryMethod_clearParser<WithStreamedUnaryMethod_insertRelationExp<WithStreamedUnaryMethod_clearRelationExp<WithStreamedUnaryMethod_clearResMap<WithStreamedUnaryMethod_modResMap<WithStreamedUnaryMethod_setDefaultGateEntry<WithStreamedUnaryMethod_setNoTable<WithStreamedUnaryMethod_setActionProc<WithStreamedUnaryMethod_setMemConfig<WithStreamedUnaryMethod_setFieldInfo<WithStreamedUnaryMethod_clearOldConfig<WithStreamedUnaryMethod_setMissActId<WithStreamedUnaryMethod_insertSramEntry<WithStreamedUnaryMethod_insertTcamEntry<WithStreamedUnaryMethod_insertAction<WithStreamedUnaryMethod_clearAction<WithStreamedUnaryMethod_delAction<Service > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace rp4


#endif  // GRPC_controller_5fto_5fdataplane_2eproto__INCLUDED
