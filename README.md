# IPSA-ipbm

This is the updated version of the reference rP4 software switch (***ipbm*** - In-situ Programmable Behavioral Model). It consists of low-level dataplane which simulates the runtime programmable hardware and cosrresponding P4-rP4 compiler.

***ipbm*** is the experimental software used to verify the feasibility of runtime programming of dataplane, and it cannot compile the P4 files used in Tofino, but the P4 files that can compiled by p4c in **bmv2**.

This repository has four main components:
- ipbm-old: old version of ipbm (controller and dataplane)
- **sw-src**: updated version of ipbm (controller interface and dataplane)
- rp4c-old: old version of rP4 compiler
- **rP4-compiler**: updated version of rP4 compiler (P4->rP4, rP4->json, runtime controller)

# Attention Please
**We have refactored the software behavioral model and designed three simple use cases that can run on `ipbm`. Please refer to the branch [use_case_version](https://github.com/jijinfanhua/IPSA-ipbm/tree/use_case_version) for the new version and use case running. The compiler hasn't been updated.**

# Dependencies
- Update the gcc version above 8, so that `std2a` can be used to compile the compiler source code.

- Install cmake, [pcap](https://www.tcpdump.org/), [yaml-cpp](https://github.com/jbeder/yaml-cpp), [glog](https://github.com/google/glog), [gflags](https://github.com/gflags/gflags)

- Install [p4c](https://github.com/p4lang/p4c), so that the intermmediate representation can be generated.

- Install [grpc](https://github.com/grpc/grpc), so that the controller can connect to the dataplane.

# Front-end compiler build and run
For the rP4 front-end compiler,
```shell
cd rP4-compiler/p4r/
make
``` 
after that, the front-end compiler ***p4r*** is generated.Use the command below to compile the json file generated by *p4c* to *.rp4*.
```shell
./p4r <p4ir json> <rp4 name>
```

# Back-end compiler build and run
For the rP4 back-end compiler,
```shell
cd rP4-compiler/rp4c
make
```
after that, the back-end compiler ***rp4_compiler*** and the runtime compiler ***rp4c*** are generated. Use the command below to compile the rP4 file to json that can be recognized by the dataplane.
```shell
./rp4_compiler <rp4 file> <ipbm json file>
```
As for runtime compiler, use the command below to update the dataplane,
```shell
compile <rp4 updated file> <rp4 update json>
```
and use `table_add` and `table_del` for table entry modification, 
```shell
table_add <table_name> <action_name> <key> => <action_para>
table_del <table_name> <key>
```

# Runtime programmable dataplane
For the runtime programmable dataplane, 
```shell
mkdir -p build && cd build
cmake ..
make -j
```
We should build the network topology with `ip netns`. The example topologies can be seen in `sw-src/script`.

To run the switch and load initial configuration, 
```shell
cd build
sudo bash ../sw-src/script/router.sh
sudo ip netns exec R2 ./bin/main -logtostderr=1 -ifconf ../sw-src/conf/router.yml
sudo ip netns exec R2 ./bin/ctrl_init_dataplane ../sw-src/controller/basic.json
sudo ip netns exec R2 ./bin/ctrl_mod_table <table entry json generated by `rp4c`>
# connectivity test
sudo ip netns exec R1 ping 10.0.2.50 -c 4
sudo ip netns exec R3 ping 10.0.1.50 -c 4
```
use the command below to update.
```shell
sudo ip netns exec R2 ./bin/ctrl_init_dataplane <updated rp4 json>
```

In this example, we use the [basic.p4](https://github.com/p4lang/tutorials/tree/master/exercises) in bmv2, and the topology is a simple `R1<->R2(switch)<->R3` topology. Reseachers can use other P4 files and new topologies to test for their runtime applications.



